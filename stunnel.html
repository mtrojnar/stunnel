<HTML>
<HEAD><TITLE>Manual page</TITLE></HEAD>
<BODY><DL>
<DT><H1>STUNNEL(8)</H1><DD>
<P><DT><H2>NAME</H2><DD>
stunnel - universal SSL tunnel
<P><DT><H2>SYNOPSIS</H2><DD>
<B>stunnel</B>
[-T] [-p pemfile] [-v level] [-a directory]
[-t timeout] [-u username] [-n protocol]
[-d [ip:]port [-f]] [ -l program | -r [ip:]port | -L program [-- args] ]
<P>
<B>stunnel</B>
{-c} [-p pemfile] [-v level] [-a directory]
[-t timeout] [-u username] [-n protocol]
-r [ip:]port [ -d [ip:]port [-f] | -l program | -L program [-- args] ]
<P><DT><H2>DESCRIPTION</H2><DD>
The <B>stunnel</B> program is designed to work as <I>SSL</I> encryption wrapper 
between remote clients and local (<I>inetd</I>-startable) or remote
servers. The concept is that having non-SSL aware daemons running on
your system you can easily set them up to communicate with clients over
secure SSL channels.
<P>
<B>stunnel</B>
can be used to add SSL functionality to commonly used <I>inetd</I>
daemons like POP-2, POP-3, and IMAP servers, to standalone daemons like
NNTP, SMTP and HTTP, and in tunneling PPP over network sockets without
changes to the source code.
<P>
This product includes cryptographic software written by
Eric Young (<A HREF="MAILTO:eay@cryptsoft.com">eay@cryptsoft.com</A>)
<P><DT><H2>OPTIONS</H2><DD>
<B>-c</B>
client mode (remote service uses SSL)
<BLOCKQUOTE>
default: server mode
</BLOCKQUOTE>
<P>
<B>-T</B>
transparent proxy mode (on hosts that support it)
<P>
<B>-p pemfile</B>
certificate (*.pem) file name
<BLOCKQUOTE>
default: /usr/local/ssl/certs/stunnel.pem for server mode,
none for client mode
</BLOCKQUOTE>
<P>
<B>-v level</B>
verify peer certificate
<BLOCKQUOTE>
level 1 - verify peer certificate if present
level 2 - verify peer certificate
level 3 - verify peer with locally installed certificate
default: no verify
</BLOCKQUOTE>
<P>
<B>-a directory</B>
client certificate directory for -v 3 option
<BLOCKQUOTE>
default: /usr/local/ssl/certs/trusted
</BLOCKQUOTE>
<P>
<B>-t timeout</B>
session cache timeout
<BLOCKQUOTE>
default: 300 s.
</BLOCKQUOTE>
<P>
<B>-u user</B>
Use IDENT (RFC 1413) username checking
<P>
<B>-n proto</B>
Negotiate SSL with specified protocol
<BLOCKQUOTE>
currenty supported: smtp
</BLOCKQUOTE>
<P>
<B>-d [ip:]port</B>
daemon mode (ip defaults to INADDR_ANY)
<BLOCKQUOTE>
default: inetd mode
</BLOCKQUOTE>
<P>
<B>-f</B>
foreground mode (don't fork, log to stderr)
<BLOCKQUOTE>
default: background in daemon mode
</BLOCKQUOTE>
<P>
<B>-l program [-- args]</B>
<BLOCKQUOTE>
execute local inetd-type program
</BLOCKQUOTE>
<P>
<B>-L program [-- args]</B>
<BLOCKQUOTE>
open local pty and execute program
</BLOCKQUOTE>
<P>
<B>-s username</B>
<BLOCKQUOTE>
setuid() to username in daemon mode
</BLOCKQUOTE>
<P>
<B>-g groupname</B>
<BLOCKQUOTE>
setgid() to groupname in daemon mode. Clears all other groups.
<P>
<B>-r [ip:]port</B>
connect to remote service
<BLOCKQUOTE>
(ip defaults to INADDR_LOOPBACK)
</BLOCKQUOTE>

<P><DT><H2>EXAMPLES</H2><DD>
In order to provide SSL encapsulation to your local <I>imapd</I> service, use

<BLOCKQUOTE>
<PRE>stunnel -d 993 -l /usr/sbin/imapd -- imapd</PRE>
</BLOCKQUOTE>
<P>
If you want to provide tunneling to your <I>pppd</I> daemon on port 2020,
use something like

<BLOCKQUOTE>
<PRE>stunnel -d 2020 -L /usr/sbin/pppd -- pppd local</PRE>
</BLOCKQUOTE>

<P><DT><H2>CERTIFICATES</H2><DD>
Each SSL enabled daemon needs to present a valid X.509 certificate
to the peer. It also needs a private key to decrypt the incoming
data. The easiest way to obtain a certificate and a key is to 
generate them with the free <I>openssl</I> package. You can find more
information on certificates generation on pages listed below.
<P>
Two things are important when generating certificate-key pairs for
<B>stunnel</B>. The private key cannot be encrypted, because the server
has no way to obtain the password from the user. To produce an
unencrypted key add the <I>-nodes</I> option when running the <I>req</I>
command from the <I>openssl</I> kit.
<P>
The order of contents of the <I>.pem</I> file is also important.
It should contain the unencrypted private key first, then a signed certificate
(not certificate request).
There should be also empty lines after certificate and private key.
Plaintext certificate information appended on the top of generated certificate
should be discarded. So the file should look like this:

<PRE>-----BEGIN RSA PRIVATE KEY-----
[encoded key]
-----END RSA PRIVATE KEY-----
[empty line]
-----BEGIN CERTIFICATE-----
[encoded certificate]
-----END CERTIFICATE-----
[empty line]</PRE>

<P><DT><H2>LIMITATIONS</H2><DD>
<I>stunnel</I> cannot be used for the FTP daemon because of the nature
of the FTP protocol which utilizes multiple ports for data transfers.
There are available SSL enabled versions of FTP and telnet daemons, however.
<P><DT><H2>SEE ALSO</H2><DD>
<FONT FACE="Roman"><B>tcpd (8),</FONT></B>
<FONT FACE="Roman"><B>inetd (8)</FONT></B>
<P>
<I><B><A HREF="http://mike.daewoo.com.pl/computer/stunnel">http://mike.daewoo.com.pl/computer/stunnel</A></I></B>
Stunnel homepage
<P>
<I><B><A HREF="http://www.openssl.org">http://www.openssl.org</A></I></B>
OpenSSL project website
<P><DT><H2>AUTHORS</H2><DD>
Michal Trojnara &lt;<A HREF="MAILTO:Michal.Trojnara@centertel.pl">Michal.Trojnara@centertel.pl</A>&gt;
<P>
Adam Hernik &lt;<A HREF="MAILTO:adas@infocentrum.com">adas@infocentrum.com</A>&gt;
<P>
Pawel Krawczyk &lt;<A HREF="MAILTO:kravietz@ceti.com.pl">kravietz@ceti.com.pl</A>&gt;
<P>
PTY support by Dirk O. Siebnich &lt;<A HREF="MAILTO:dok@vossnet.de">dok@vossnet.de</A>&gt;
</DL></BODY>
</HTML>
